# -*- coding: utf-8 -*-
"""Modelos lineales-Consumo Electrico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qdn8z2d2_pXOCkO0--nefGxwiAJz8wz4

**Preprocesamiento de la base de datos de Consumo Electrico**

Este archivo consta de los codigos y conclusiones de:
* 1.Separar en datos de entrenamiento y de prueba.
* 2.Preparar datos para realizar aprendizaje supervizado.

# Carga de Librerias y Datos

*Se importan los módulos necesarios para trabajar*
"""

#Pandas es utilizado para leer los set de datos
import pandas as pd
#Numpy es utilizado para generar las series de datos a graficar
import numpy as np
#Seaborn es utilizado para generar los gráficos
import seaborn as sns
import matplotlib.pyplot as plt
#Se importan modulos estadisticos para generar test de hipotesis, entre otros
from sklearn.preprocessing import StandardScaler
#Módulos implementa funciones que evalúan el error de predicción para propósitos específicos
from sklearn.metrics import mean_absolute_error as mae
from sklearn.metrics import mean_absolute_percentage_error as mape
from sklearn.metrics import mean_squared_error as mse
#Ignorar warnings
import warnings
warnings.filterwarnings("ignore")
#Modulos para trabajar con Arima y Sarimax
from statsmodels.tsa.seasonal import seasonal_decompose
import statsmodels.api as sm
from statsmodels.graphics.tsaplots import plot_predict
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX

#Dividir arreglos o matrices en subconjuntos aleatorios de tren y prueba
from sklearn.model_selection import train_test_split

import warnings
warnings.filterwarnings("ignore")

!pip install pmdarima --quiet
import pmdarima as pm

# Para acceder a los archivos del gdrive
from google.colab import drive
drive.mount('/content/gdrive/')

cd /content/gdrive/MyDrive/Tesis/Datos-2

df=pd.read_csv('df_EDA.csv',
                parse_dates={'dt':['Date','time']},
                infer_datetime_format=True,
                low_memory=False,
                index_col='dt')

df.info()

df.shape

## resampling of data over hour
df = df.resample('D').mean()
df.shape

df

#Seleccion de caracteristicas
features =df.columns

#Se define escalado
std_scaler = StandardScaler()
#Transformacion

for i in features:
  df[i] = std_scaler.fit_transform(df[i].values.reshape(-1,1))

df.head()

"""#2.Separar en conjunto de entrenamiento y de test"""

# Porcentaje de train.
p_train = 0.80

largo_data=df.shape[0]

#Separacion lineal del dataset
train=df.iloc[0:int(largo_data*p_train),:]
test=df.iloc[int(largo_data*p_train):largo_data,:]

train.tail()

"""#Arima

Modelo ARIMA para pronósticos de series temporales ARIMA significa modelo de promedio móvil integrado autorregresivo y se especifica mediante tres
parámetros de orden: (p, d, q).

* **AR( p ) Autorregresión** : un modelo de regresión que utiliza la relación dependiente entre una observación actual y las observaciones durante un período anterior. Un componente autorregresivo ( AR(p) ) se refiere al uso de valores pasados ​en la ecuación de regresión para la serie temporal .

* **I( d ) Integración** : utiliza la diferenciación de observaciones (restando una observación de la observación en el paso de tiempo anterior) para hacer que la serie de tiempo sea estacionaria. La diferenciación implica la resta de los valores actuales de una serie con sus valores anteriores d número de veces.

* **MA( q ) Promedio móvil** : un modelo que utiliza la dependencia entre una observación y un error residual de un modelo de promedio móvil aplicado a observaciones retrasadas. Un componente de promedio móvil representa el error del modelo como una combinación de términos de error anteriores. El orden q representa el número de términos a incluir en el modelo.

Del modelo:
* Se entrena modelo Auto_Arima para encontrar los mejores coeficientes del modelo.
* Variable objetivo a predecir Global active power
* Se entrena con 10377 pasos hacia delante
* Se obtiene precision del modelo con metricas MAPE y RMSE
"""

target="Global_active_power"

def Auto_Arima(data,trace_value):
  ARIMA_model = pm.auto_arima(data,
                        test='adf',
                        max_p=3, max_q=3,
                        m=7,
                        d=None,
                        seasonal=False,
                        trace=trace_value,
                        error_action='warn',
                        suppress_warnings=True,
                        stepwise=True)
  return ARIMA_model

#Entrenamiento del modelo Arima
Arima_model=Auto_Arima(train[target],True)

#Prediccion del modelo Arima
#Se entrena con 10377 pasos hacia delante
n_periods=len(test)
Arima_forecast=Arima_model.predict(n_periods=n_periods)
Arima_forecast_df = pd.DataFrame(Arima_forecast.values,index = test.index,columns=['Prediction'])

pd.concat([Arima_forecast_df,test[target]],axis=1).plot(figsize=(20, 5))

result_mse = mse(test[target], Arima_forecast)
result_mape = mape(test[target], Arima_forecast)
result_mae = mae(test[target], Arima_forecast)

print(f'mse: {result_mse}')
print(f'mae: {result_mae}')
print(f'mape: {result_mape}')

"""#Sarima

Del modelo:
* Se entrena modelo Auto Sarima para encontrar los mejores coeficientes del modelo.
* Variable objetivo a predecir Global active power
* Se entrena con 10377 pasos hacia delante
* Se obtiene precision del modelo con metricas MAPE y RMSE
"""

def Auto_Sarima(data,trace_value):
  SARIMAX_model = pm.auto_arima(data,
                        test='adf',
                        max_p=7, max_q=7,
                        m=7,
                        d=None,
                        seasonal=True,
                        trace=trace_value,
                        error_action='warn',
                        suppress_warnings=True,
                        n_jobs=-1,
                        stepwise=True)
  return SARIMAX_model

#Entrenamiento del modelo Arima
Sarima_model=Auto_Sarima(train[target],True)

Sarima_forecast = Sarima_model.predict(n_periods=len(test))
Sarima_forecast

#Prediccion del modelo Arima
#Se entrena con 10377 pasos hacia delante
Sarima_forecast = Sarima_model.predict(n_periods=len(test))
Sarima_forecast_df = pd.DataFrame(Sarima_forecast.values,index = test.index,columns=['Prediction'])

#Grafico
pd.concat([Sarima_forecast_df,test[target]],axis=1).plot(figsize=(10, 5))

result_mse = mse(test[target], Sarima_forecast)
result_mape = mape(test[target], Sarima_forecast)
result_mae = mape(test[target], Sarima_forecast)

print(f'mse: {result_mse}')
print(f'mae: {result_mae}')
print(f'mape: {result_mape}')