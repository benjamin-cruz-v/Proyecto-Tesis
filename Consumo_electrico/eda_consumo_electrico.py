# -*- coding: utf-8 -*-
"""EDA-Consumo Electrico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PGAfdSDORGZUzm5ih0wtYzlVOUR94J_b

# Descripcion de Datos

**Acerca del conjunto de datos**

Mediciones del consumo de energía eléctrica en un hogar con una frecuencia de muestreo de un minuto durante un período de casi 4 años. Están disponibles diferentes magnitudes eléctricas y algunos valores de submedición.

**Información del conjunto de datos:**

Este archivo contiene 2.075.259 mediciones recopiladas entre diciembre de 2006 y noviembre de 2010 (47 meses).

**Notas**:

1.(energía_activa_global*1000/60 - sub_medición_1 - sub_medición_2 - sub_medición_3) representa la energía activa consumida cada minuto (en vatios hora) en el hogar por equipos eléctricos no medidos en las submediciones 1, 2 y 3.


2.El conjunto de datos contiene algunos valores faltantes en las mediciones (casi el 1,25 % de las filas). Todas las marcas de tiempo del calendario están presentes en el conjunto de datos, pero para algunas marcas de tiempo faltan los valores de medición: un valor faltante se representa por la ausencia de valor entre dos separadores de atributos de punto y coma consecutivos. Por ejemplo, el conjunto de datos muestra valores faltantes el 28 de abril de 2007.


**Información de atributos:**

1.fecha: Fecha en formato dd/mm/aaaa

2.time: hora en formato hh:mm:ss

3.global_active_power: potencia activa promedio por minuto global del hogar (en kilovatios)

4.global_reactive_power: potencia reactiva global promediada por minuto del hogar (en kilovatios)

5.voltage: voltaje promedio por minuto (en voltios)

6.global_intensity: intensidad de corriente promediada global por minuto del hogar (en amperios)

7.sub_metering_1: submedición de energía N° 1 (en vatios-hora de energía activa). Corresponde a la cocina, compuesta principalmente por lavavajillas, horno y microondas (las placas de cocción no son eléctricas sino de gas).

8.sub_metering_2: submedición de energía N° 2 (en vatios-hora de energía activa). Corresponde al lavadero, que contiene lavadora, secadora, frigorífico y luz.

9.sub_metering_3: submedición de energía nº 3 (en vatios-hora de energía activa). Corresponde a un termo eléctrico y un aire acondicionado.

# Carga de Librerias y Datos
"""

#Se importan los módulos necesarios para trabajar
#Pandas es utilizado para leer los set de datos
import pandas as pd
#Numpy es utilizado para generar las series de datos a graficar
import numpy as np
#Matplotlib es utilizado para generar los gráficos
import matplotlib.pyplot as plt
import missingno as msno
#Seaborn es utilizado para generar los gráficos
import seaborn as sns
#Se importan modulos estadisticos para generar test de hipotesis, entre otros
from scipy.stats import normaltest
from scipy.stats import norm
from scipy import stats
from scipy.stats import shapiro
from scipy.stats import anderson
from scipy.stats import spearmanr

# Para acceder a los archivos del gdrive
from google.colab import drive
drive.mount('/content/gdrive/')

cd /content/gdrive/MyDrive/Tesis/Datos-2

df=pd.read_csv('household_power_consumption.txt',sep=";",
                parse_dates={'dt':['Date','Time']},
                infer_datetime_format=True,
                low_memory=False,
                na_values=['nan','?'],
                index_col='dt')

"""# Resumen de datos cargados

"""

df

df.info()

"""# Procesamiento

*Compruebe si una columna contienen al menos un valor faltante*
"""

print(df.isnull().any())

df.isnull().sum()

nan_rows = df[df.isnull().any(1)]
nan_rows

"""**insight**: Se comprueba que el conjunto de datos presenta un total de 25.979 datos nulos

---

*Se analiza si hay mediciones que sean 0 en cada variable.*
"""

for i in df.columns:
  print(i)
  display(df[i].value_counts().head(6))
  print('_________________________________________________')
  print(' ')

"""**insight**: Se comprueba que:
*   Global_reactive_power presentan 488801 datos igual a cero.
*   Sub_metering_1 presentan 1880175 datos igual a cero.
*   Sub_metering_2 presentan 1436830 datos igual a cero.
*   Sub_metering_3 presentan 852092 datos igual a cero.

---

## Limpieza del conjunto de datos
Se puede observar un total de 25979 datos nulos en todas las columnas:

Para este problema, se utiliza relleno hacia adelante o relleno hacia atrás. Motivo: Los registros con valores nulos están en el medio y la potencia utilizada se registra cada minuto durante 3-4 años. ffill() llenará la última observación válida en el siguiente registro nulo encontrado.
"""

df.ffill(axis=0,inplace=True)
df.isnull().sum()

"""## Creacion  de variable de other_consumption y variable de tiempo

Se crea la variable objetivo 'other_consumtion' para obtener el consumo energetico de equipos y artefactos eléctricos que no medidos en sub mediciones 1, 2, 3.

Energía activa global [KW*min⁡]:

* Energia total de la casa consumida por los equipos eléctricos y que se convierte en trabajo. En este hogar existen 3 submediciones:

* **submedición 1** [W*h]: Corresponde a la cocina, compuesta principalmente por lavavajillas, horno y microondas.

* **submedición 2** [W*h]: Corresponde al lavadero, que contiene lavadora, secadora, frigorífico y luz.

* **submedición 3** [W*h]: Corresponde a un termo eléctrico y un aire acondicionado.

Por otro lado, existen otros consumos de energía electrica que se pueden obtener de la diferencia entre la Energía activa global y la sumatoria de las 3 submediciones.


Para la creación de una de las variables objetivo, otros consumos, se utiliza la siguiente formula:

* **Otros consumo**= energia Activa total-(Submedicion 1+Submedicion 2 +Submedicion 3

Debido a que la variable Energía global activa presenta unidades de medida diferentes a las unidades de medida que presentan las 3 sub estaciones, se debe realizar un cambio de unidades de medición a la variable Energía activa global de la siguiente forma:

* KW*min(1000 W/1 KW) + (1H/ 60 min)=16.667[Wh]
"""

# 'Global_active_power' se encuentra con unidades [KW*min] y se pasa a Wh debido a que las sub estaciones se encuentran en Wh
eq1=df['Global_active_power']*1000/60
eq2=df['Sub_metering_1']+df['Sub_metering_2']+df['Sub_metering_3']
df['other_consumption']=eq1-eq2
df.head()

"""Se crean dos columnas más desde el índice, columna de fecha y hora por separado"""

df['Date'] = df.index.date
df['time'] = df.index.time
df['Date'] = pd.to_datetime(df['Date'])
df.head()

"""*Se crean las variables de tiempo año, dia, semana y dia para analizar*"""

df["Year"] = df["Date"].dt.year
df["Month"] = df["Date"].dt.month
df["Day"] = df["Date"].dt.day
df["Week"] = df["Date"].dt.week

df

"""#Analisis Exploratorio de Datos

##Analisis univariado

### Se comprueba que cada año tenga la cantidad de registros correspondientes

Usando la formula:

* [dias del año] * 24 hrs * 60 min= Nº de registros.


Para los años 2006, 2007, 2009 y 2010 los dias del años son 365, para el caso de 2008 año bisiesto se tiene 366.

En base a esto:
* 365 * 24 hrs * 60 min= 525.600
* 366 * 24 hrs * 60 min= 527.040
"""

print(df['Year'].value_counts())

plt.subplots(figsize=(15,3))
sns.countplot(data=df, x="Year")
plt.title("Cantidad de registros por semana")
plt.show()

"""**insight**:
* Se comprueba que el año **2006** tiene menos registros dado que el conjunto de datos se empezo a medir desde diciembre y **2010** lo mismo ya que termina en noviembre

* Los años **2007**, **2008** y **2009** tienen la cantidad correspondiente de registros de datos.

---

####Analisis de 2010

Para el año 2010 dado que la ultima medicion se realizo el 26 de Novimebre de ese año, siendo el dia 330.

* 330 * 24 hrs * 60 min= 475.200

Esto contrata con los 475.023 que hay en la dataset, con una diferencia de **177** regsitros sin contar.

Fuente:https://espanol.epochconverter.com/dias/2010
"""

df_2010=df[df['Year']==2010]

"""Analisis por mes del año 2010, donde:

* [dias del mes] * 24 hrs * 60 min

Para:

* 31= 44.640
* 30= 40.320
* 28= 40.320


"""

plt.subplots(figsize=(15,3))
sns.countplot(data=df_2010, x="Month")
plt.title("Cantidad de registros por semana")
plt.show()

print(df_2010['Month'].value_counts())

"""**insight**: Cada mes tiene la cantidad correcta de registros a excepcion del mes 11, donde se termina de medir el dataset.

---

*Se analiza el año 2010 en el mes de 11 (Noviembre)*
"""

df_2010_mes=df_2010[df_2010['Month']==11]

print(df_2010_mes['Day'].value_counts())

plt.subplots(figsize=(15,3))
sns.countplot(data=df_2010_mes, x="Day")
plt.title("Cantidad de registros por semana")
plt.show()

"""**insight**: El dia 26 el ultimo dia de registro se cuenta con 1263 registros, siendo 177 registros menos. Encontrando donde estaban los datos faltantes

---
"""

#  Se filtran los datos posterior al año 2006
df=df[df.index.year>2006]
display(df.head())
display(df.shape)

"""###Análisis de Normalidad

**Shapiro-Wilk test**

Comprueba si una muestra de datos tiene una distribución gaussiana.

Supuestos

Las observaciones en cada muestra son independientes e idénticamente distribuidas (iid).

Interpretación

H0: la muestra tiene una distribución gaussiana.
H1: la muestra no tiene distribución gaussiana.
"""

def shapiro(data):
  stat, p = stats.shapiro(df[data])
  print("Analisis de: "+data)
  print('stat=%.3f, p=%.3f' % (stat, p))
  if p > 0.05:
    print('Probably Gaussian')
    print("")
  else:
    print('Probably not Gaussian')
    print("")

shapiro('Global_active_power')
shapiro('Global_reactive_power')
shapiro('Voltage')
shapiro('Global_intensity')
shapiro('Sub_metering_1')
shapiro('Sub_metering_2')
shapiro('Sub_metering_3')
shapiro('other_consumption')

"""**insight**: Secomprueba que los datos no siguen una distribucion normal


---

##Analisis Bivariado

###Analisis de consumo por fecha en el tiempo
"""

#Se crea funcion para graficar las variables en el tiempo elegido (mes, año, semana, etc)
def grafico_lineas_(data,ejex,ejey,columna,tipo_fecha):
      ax[ejex,ejey].plot(data[tipo_fecha], data[columna])
      ax[ejex,ejey].set_ylabel(columna)
      ax[ejex,ejey].set_xlabel(tipo_fecha)
      ax[ejex,ejey].set_title('Grafico de: '+columna)

df_date=df.groupby(['Date',]).mean().reset_index()

fig, ax = plt.subplots(4,2,figsize=(25,18))
fig.subplots_adjust(wspace=0.5, hspace=0.5)
fig.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9)
aux='Date'
grafico_lineas_(df_date,0,0,'Global_active_power',aux)
grafico_lineas_(df_date,0,1,'Global_reactive_power',aux)
grafico_lineas_(df_date,1,0,'Voltage',aux)
grafico_lineas_(df_date,1,1,'Global_intensity',aux)
grafico_lineas_(df_date,2,0,'Sub_metering_1',aux)
grafico_lineas_(df_date,2,1,'Sub_metering_2',aux)
grafico_lineas_(df_date,3,0,'Sub_metering_3',aux)
grafico_lineas_(df_date,3,1,'other_consumption',aux)

plt.tight_layout()
plt.show()

"""Funcines para graficar variables en el tiempo"""

#Grafico que genera el comportamiento de la variable desglosado por año
def grafico_lineas_year(df,columna,group):
  consumo_2007 = df[(df['Year']==2007)].groupby(group)[columna].mean()
  consumo_2008 = df[(df['Year']==2008)].groupby(group)[columna].mean()
  consumo_2009 = df[(df['Year']==2009)].groupby(group)[columna].mean()
  consumo_2010 = df[(df['Year']==2010)].groupby(group)[columna].mean()

  plt.figure(figsize=(10,3))
  plt.plot(consumo_2007.index, consumo_2007.values)
  plt.plot(consumo_2008.index, consumo_2008.values)
  plt.plot(consumo_2009.index, consumo_2009.values)
  plt.plot(consumo_2010.index, consumo_2010.values)

  plt.yticks( fontsize=10)
  plt.xlabel(group, fontsize=10, labelpad=8)
  plt.ylabel(columna, fontsize=10, labelpad=10)

  plt.title("Grafico de consumo de:  "+columna, fontsize=10)
  plt.legend(['2007','2008', '2009', '2010'], fontsize=10)

  plt.tight_layout()
  plt.show()

#Grafico que genera el comportamiento de la variable
def grafico_lineas_(df,columna):
  plt.figure(figsize=(10,3))
  plt.plot(df.index, df[columna].values)
  plt.yticks( fontsize=10)
  plt.ylabel(columna, fontsize=10, labelpad=10)
  plt.title("Grafico de consumo de:  "+columna, fontsize=10)
  plt.tight_layout()
  plt.show()

"""###Analisis de consumo por mes"""

aux="Month"
grafico_lineas_year(df,'Global_active_power',aux)
grafico_lineas_year(df,'Global_reactive_power',aux)
grafico_lineas_year(df,'Voltage',aux)
grafico_lineas_year(df,'Global_intensity',aux)
grafico_lineas_year(df,'Sub_metering_1',aux)
grafico_lineas_year(df,'Sub_metering_2',aux)
grafico_lineas_year(df,'Sub_metering_3',aux)
grafico_lineas_year(df,'other_consumption',aux)

df_month = df.resample('M').mean()
grafico_lineas_(df_month,'Global_active_power')
grafico_lineas_(df_month,'Global_reactive_power')
grafico_lineas_(df_month,'Voltage')
grafico_lineas_(df_month,'Global_intensity')
grafico_lineas_(df_month,'Sub_metering_1')
grafico_lineas_(df_month,'Sub_metering_2')
grafico_lineas_(df_month,'Sub_metering_3')
grafico_lineas_(df_month,'other_consumption')

"""###Analisis de consumo por semana"""

aux="Week"
grafico_lineas_year(df,'Global_active_power',aux)
grafico_lineas_year(df,'Global_reactive_power',aux)
grafico_lineas_year(df,'Voltage',aux)
grafico_lineas_year(df,'Global_intensity',aux)
grafico_lineas_year(df,'Sub_metering_1',aux)
grafico_lineas_year(df,'Sub_metering_2',aux)
grafico_lineas_year(df,'Sub_metering_3',aux)
grafico_lineas_year(df,'other_consumption',aux)

df_week = df.resample('W').mean()
grafico_lineas_(df_week,'Global_active_power')
grafico_lineas_(df_week,'Global_reactive_power')
grafico_lineas_(df_week,'Voltage')
grafico_lineas_(df_week,'Global_intensity')
grafico_lineas_(df_week,'Sub_metering_1')
grafico_lineas_(df_week,'Sub_metering_2')
grafico_lineas_(df_week,'Sub_metering_3')
grafico_lineas_(df_week,'other_consumption')

"""###Analisis de consumo por dia"""

aux="Day"
grafico_lineas_year(df,'Global_active_power',aux)
grafico_lineas_year(df,'Global_reactive_power',aux)
grafico_lineas_year(df,'Voltage',aux)
grafico_lineas_year(df,'Global_intensity',aux)
grafico_lineas_year(df,'Sub_metering_1',aux)
grafico_lineas_year(df,'Sub_metering_2',aux)
grafico_lineas_year(df,'Sub_metering_3',aux)
grafico_lineas_year(df,'other_consumption',aux)

days = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday', 'Sunday']
df_day = df.groupby(df.index.day_name()).mean().reindex(days)

grafico_lineas_(df_day,'Global_active_power')
grafico_lineas_(df_day,'Global_reactive_power')
grafico_lineas_(df_day,'Voltage')
grafico_lineas_(df_day,'Global_intensity')
grafico_lineas_(df_day,'Sub_metering_1')
grafico_lineas_(df_day,'Sub_metering_2')
grafico_lineas_(df_day,'Sub_metering_3')
grafico_lineas_(df_day,'other_consumption')

"""##Analisis Multivariado

###Análisis de Correlacion

*Se aplica correlacion spearman*
"""

features = [feature for feature in df.columns if feature not in ('Date','Day','Year')]
df_=df[features]
df_.tail()

plt.figure(figsize=(10,10))
sns.heatmap(
    df.corr("spearman"),
    annot     = True,
    cbar      = True,
    annot_kws = {"size": 8},
    vmin      = -1,
    vmax      = 1,
    center    = 0,
    cmap      = sns.diverging_palette(20, 220, n=200),
    square    = True,
)

fig, ax = plt.subplots(figsize=(3,6))
corr = df.corr('pearson')[['Global_active_power']].sort_values(by='Global_active_power', ascending=False)
sns.heatmap(corr, annot=True)

"""#Se analiza la correlacion de variables"""

features = [feature for feature in df.columns if feature not in ('Date','Day','Year','time')]
df2=df[features]

data_returns = df2.pct_change()
sns.jointplot(x='Global_intensity', y='Global_active_power', data=data_returns)
plt.show()

sns.jointplot(x='Global_intensity', y='Voltage', data=data_returns)
plt.show()

"""**insight**:


---

**insight**:

De la correlacion se obtiene que:




---

#Análisis de valores atípicos

##Aplicando boxplots
"""

def boxplot_data(dataframe):
  plt.figure(figsize = (15,3))
  dataframe.boxplot()
  plt.show()

boxplot_data(df)

from math import pi

salario_anual_miles =np.array(df.Voltage)
media = (salario_anual_miles).mean()
std_x = (salario_anual_miles).std()*2
#media_y = (edades).mean()
#std_y = (edades).std()*2

colors = ['blue']*len(salario_anual_miles)
for index, x in enumerate(salario_anual_miles):
    if abs(x-media) > std_x:
        colors[index] = 'red'
''''
for index, x in enumerate(edades):
    if abs(x-media_y) > std_y:
        colors[index] = 'red'
 '''
#plt.scatter(edades, salario_anual_miles, s=100, color=colors)
plt.axhline(media, color='k', linestyle='--')
#plt.axvline(media_y, color='k', linestyle='--')

v=media     #y-position of the center
#u=media_y    #x-position of the center
b=std_x     #radius on the y-axis
#a=std_y    #radius on the x-axis

t = np.linspace(0, 2*pi, 100)
#plt.plot( u+a*np.cos(t) , v+b*np.sin(t) )

plt.xlabel('Edad')
plt.ylabel('Salario Anual (miles)')
plt.show()

Q1=df.Voltage.quantile(0.25)
print("Primer cuartil:",Q1)
Q3=df.Voltage.quantile(0.75)
print("Tercer cuartil:",Q3)
IQR=Q3-Q1
print("Rango intercuartil:",IQR)
max=df.Voltage.max()
print("Maximo de V1: ",max)
min=df.Voltage.min()
print("minimo de V1:",min)

upper = Q3+1.5*IQR
lower = Q1-1.5*IQR
print("upper:",upper)
print("lower:",lower)
filter1 = df.Voltage <= upper
filter2 = df.Voltage >= lower

df.where(filter1 & filter2, inplace = True)



"""#Resumen de Conclusiones"""

features = [feature for feature in df.columns if feature not in ('Year','Week','Month','Day')]
df=df[features]

df.to_csv('df_EDA.csv', index = False)

"""A partir del EDA realizado se obtiene que:

*


"""